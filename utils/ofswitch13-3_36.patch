diff --git a/build-support/custom-modules/ns3-configtable.cmake b/build-support/custom-modules/ns3-configtable.cmake
index 40839ed2f..f6288086d 100644
--- a/build-support/custom-modules/ns3-configtable.cmake
+++ b/build-support/custom-modules/ns3-configtable.cmake
@@ -149,6 +149,9 @@ macro(write_configtable)
   string(APPEND out "NS-3 Click Integration        : ")
   check_on_or_off("ON" "${NS3_CLICK}")
 
+  string(APPEND out "NS-3 OFSwitch13 Integration   : ")
+  check_on_or_off("ON" "${NS3_OFSWITCH13}")
+
   string(APPEND out "NS-3 OpenFlow Integration     : ")
   check_on_or_off("ON" "${NS3_OPENFLOW}")
 
diff --git a/src/csma/model/csma-net-device.cc b/src/csma/model/csma-net-device.cc
index 9913e48b3..6b5dec7b0 100644
--- a/src/csma/model/csma-net-device.cc
+++ b/src/csma/model/csma-net-device.cc
@@ -795,6 +795,30 @@ CsmaNetDevice::Receive (Ptr<Packet> packet, Ptr<CsmaNetDevice> senderDevice)
       packetType = PACKET_OTHERHOST;
     }
 
+  //
+  // Check if this device is configure as an OpenFlow switch port.
+  //
+  if (!m_openFlowRxCallback.IsNull ())
+    {
+      // For all kinds of packet we receive, we hit the promiscuous sniffer
+      // hook. If the packet is addressed to this device (which is not supposed
+      // to happen in normal situations), we also hit the non-promiscuous
+      // sniffer hook, but in both cases we don't forward the packt up the
+      // stack.
+      m_promiscSnifferTrace (originalPacket);
+      if (packetType != PACKET_OTHERHOST)
+        {
+          m_snifferTrace (originalPacket);
+        }
+
+      // We forward the original packet (which includes the EthernetHeader) to
+      // the OpenFlow receive callback for all kinds of packetType we receive
+      // (broadcast, multicast, host or other host).
+      m_openFlowRxCallback (this, originalPacket, protocol,
+        header.GetSource (), header.GetDestination (), packetType);
+      return;
+    }
+
   // 
   // For all kinds of packetType we receive, we hit the promiscuous sniffer
   // hook and pass a copy up to the promiscuous callback.  Pass a copy to 
@@ -1019,6 +1043,13 @@ CsmaNetDevice::NeedsArp (void) const
   return true;
 }
 
+void
+CsmaNetDevice::SetOpenFlowReceiveCallback (NetDevice::PromiscReceiveCallback cb)
+{
+  NS_LOG_FUNCTION (&cb);
+  m_openFlowRxCallback = cb;
+}
+
 void
 CsmaNetDevice::SetReceiveCallback (NetDevice::ReceiveCallback cb)
 {
diff --git a/src/csma/model/csma-net-device.h b/src/csma/model/csma-net-device.h
index 97d158580..8f7bef8de 100644
--- a/src/csma/model/csma-net-device.h
+++ b/src/csma/model/csma-net-device.h
@@ -306,6 +306,14 @@ public:
    */
   virtual bool NeedsArp (void) const;
 
+  /**
+   * Set the callback used to notify the OpenFlow when a packet has been
+   * received by this device.
+   *
+   * \param cb The callback.
+   */
+  virtual void SetOpenFlowReceiveCallback (NetDevice::PromiscReceiveCallback cb);
+
   /**
    * Set the callback to be used to notify higher layers when a packet has been
    * received.
@@ -688,6 +696,11 @@ private:
    */
   Mac48Address m_address;
 
+  /**
+   * The OpenFlow receive callback.
+   */
+  NetDevice::PromiscReceiveCallback m_openFlowRxCallback;
+
   /**
    * The callback used to notify higher layers that a packet has been received.
    */
diff --git a/src/network/utils/queue.h b/src/network/utils/queue.h
index f26732b77..4deb54229 100644
--- a/src/network/utils/queue.h
+++ b/src/network/utils/queue.h
@@ -315,6 +315,13 @@ protected:
   /// Iterator.
   typedef typename std::list<Ptr<Item> >::iterator Iterator;
 
+  /**
+   * Get a const reference to the container of queue items.
+   *
+   * \return a const reference to the container of queue items
+   */
+  const std::list<Ptr<Item> >& GetContainer() const;
+
   /**
    * \brief Get a const iterator which refers to the first item in the queue.
    *
@@ -498,6 +505,13 @@ Queue<Item>::~Queue ()
 {
 }
 
+template <typename Item>
+const std::list<Ptr<Item>>&
+Queue<Item>::GetContainer() const
+{
+    return m_packets;
+}
+
 template <typename Item>
 bool
 Queue<Item>::DoEnqueue (ConstIterator pos, Ptr<Item> item)
diff --git a/src/virtual-net-device/model/virtual-net-device.cc b/src/virtual-net-device/model/virtual-net-device.cc
index a0828900a..f8564cf09 100644
--- a/src/virtual-net-device/model/virtual-net-device.cc
+++ b/src/virtual-net-device/model/virtual-net-device.cc
@@ -141,6 +141,29 @@ VirtualNetDevice::Receive (Ptr<Packet> packet, uint16_t protocol,
                            const Address &source, const Address &destination,
                            PacketType packetType)
 {
+  //
+  // Check if this device is configure as an OpenFlow switch port.
+  //
+  if (!m_openFlowRxCallback.IsNull ())
+    {
+      // For all kinds of packetType we receive, we hit the promiscuous sniffer
+      // hook. If the packet is addressed to this device (which is not supposed
+      // to happen in normal situations), we also hit the non-promiscuous
+      // sniffer hook, but in both cases we don't forward the packt up the
+      // stack.
+      m_promiscSnifferTrace (packet);
+      if (packetType != PACKET_OTHERHOST)
+        {
+          m_snifferTrace (packet);
+        }
+
+      // We then forward the original packet to the OpenFlow receive callback
+      // for all kinds of packetType we receive (broadcast, multicast, host or
+      // other host).
+      m_openFlowRxCallback (this, packet, protocol, source, destination, packetType);
+      return true;
+    }
+
   // 
   // For all kinds of packetType we receive, we hit the promiscuous sniffer
   // hook and pass a copy up to the promiscuous callback.  Pass a copy to 
@@ -314,5 +337,11 @@ bool VirtualNetDevice::IsBridge (void) const
   return false;
 }
 
+void
+VirtualNetDevice::SetOpenFlowReceiveCallback (NetDevice::PromiscReceiveCallback cb)
+{
+  NS_LOG_FUNCTION (&cb);
+  m_openFlowRxCallback = cb;
+}
 
 } // namespace ns3
diff --git a/src/virtual-net-device/model/virtual-net-device.h b/src/virtual-net-device/model/virtual-net-device.h
index 1bf53a2b1..696cf3c96 100644
--- a/src/virtual-net-device/model/virtual-net-device.h
+++ b/src/virtual-net-device/model/virtual-net-device.h
@@ -151,6 +151,14 @@ public:
   virtual bool SupportsSendFrom () const;
   virtual bool IsBridge (void) const;
 
+  /**
+   * Set the callback used to notify the OpenFlow when a packet has been
+   * received by this device.
+   *
+   * \param cb The OpenFlow receive callback.
+   */
+  virtual void SetOpenFlowReceiveCallback (NetDevice::PromiscReceiveCallback cb);
+
 protected:
 
   virtual void DoDispose (void);
@@ -173,6 +181,9 @@ private:
   bool m_needsArp;          //!< True if the device needs ARP
   bool m_supportsSendFrom;  //!< True if the device supports SendFrm
   bool m_isPointToPoint;    //!< True if the device is a PointToPoint type device
+
+  /** The OpenFlow receive callback. */
+  NetDevice::PromiscReceiveCallback m_openFlowRxCallback;
 };
 
 } // namespace ns3
